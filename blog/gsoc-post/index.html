<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Throwback - GSoC 2020 | Device handler development for the SOURCE project | hi, I am robin</title>
<meta name=keywords content="gsoc,device-handler,sensors,eclipse"><meta name=description content="This is an adapted version of a blog post initially posted
on Wordpress as part of my GSoC project. It&rsquo;s a perfect
way for me to set up my own first blog which is based on
this excellent guide.
At that point of time, I was an aerospace engineer doing my graduate studies at the University
of Stuttgart. I&rsquo;m still active in the small satellite society KSat
but I am doing more of a supporting role now that I started working the University as a PhD student."><meta name=author content><link rel=canonical href=https://robamu.github.io/blog/gsoc-post/><link crossorigin=anonymous href=/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://robamu.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://robamu.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://robamu.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://robamu.github.io/apple-touch-icon.png><link rel=mask-icon href=https://robamu.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://robamu.github.io/blog/gsoc-post/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://robamu.github.io/blog/gsoc-post/"><meta property="og:site_name" content="hi, I am robin"><meta property="og:title" content="Throwback - GSoC 2020 | Device handler development for the SOURCE project"><meta property="og:description" content="This is an adapted version of a blog post initially posted on Wordpress as part of my GSoC project. It’s a perfect way for me to set up my own first blog which is based on this excellent guide.
At that point of time, I was an aerospace engineer doing my graduate studies at the University of Stuttgart. I’m still active in the small satellite society KSat but I am doing more of a supporting role now that I started working the University as a PhD student."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="blog"><meta property="article:published_time" content="2021-12-14T19:29:58+01:00"><meta property="article:modified_time" content="2023-10-03T23:12:57+02:00"><meta property="article:tag" content="Gsoc"><meta property="article:tag" content="Device-Handler"><meta property="article:tag" content="Sensors"><meta property="article:tag" content="Eclipse"><meta name=twitter:card content="summary"><meta name=twitter:title content="Throwback - GSoC 2020 | Device handler development for the SOURCE project"><meta name=twitter:description content="This is an adapted version of a blog post initially posted
on Wordpress as part of my GSoC project. It&rsquo;s a perfect
way for me to set up my own first blog which is based on
this excellent guide.
At that point of time, I was an aerospace engineer doing my graduate studies at the University
of Stuttgart. I&rsquo;m still active in the small satellite society KSat
but I am doing more of a supporting role now that I started working the University as a PhD student."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"","item":"https://robamu.github.io/blog/"},{"@type":"ListItem","position":2,"name":"Throwback - GSoC 2020 | Device handler development for the SOURCE project","item":"https://robamu.github.io/blog/gsoc-post/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Throwback - GSoC 2020 | Device handler development for the SOURCE project","name":"Throwback - GSoC 2020 | Device handler development for the SOURCE project","description":"This is an adapted version of a blog post initially posted on Wordpress as part of my GSoC project. It\u0026rsquo;s a perfect way for me to set up my own first blog which is based on this excellent guide.\nAt that point of time, I was an aerospace engineer doing my graduate studies at the University of Stuttgart. I\u0026rsquo;m still active in the small satellite society KSat but I am doing more of a supporting role now that I started working the University as a PhD student.\n","keywords":["gsoc","device-handler","sensors","eclipse"],"articleBody":"This is an adapted version of a blog post initially posted on Wordpress as part of my GSoC project. It’s a perfect way for me to set up my own first blog which is based on this excellent guide.\nAt that point of time, I was an aerospace engineer doing my graduate studies at the University of Stuttgart. I’m still active in the small satellite society KSat but I am doing more of a supporting role now that I started working the University as a PhD student.\nThe domain of my work was and still is embedded programming in C++. The most simple explanation of my work would be that I programmed the handler software for sensors and the on-board computer itself. The source code is located on the gitlab server of KSat. The extensive README provides instructions how to make the Linux version of the software work and how to setup Eclipse properly to allow convenient microcontroller development. It should be noted that the device handlers were tested on a microcontroller with FreeRTOS as the operating system. It has been really fascinating to learn about different types of sensors and their interfaces. Of course, my work included more than just making a few sensors work with something like an Arduino.\nA lot of work went into making microcontroller development as convenient as possible while also staying free and open-source. The used development environment is very much in the spirit of open-source: Eclipse was used as an IDE and the software for the target on-board computer is generated using the free ARM toolchain. The used framework is also open source and it is possible to compile the software for Linux as well (Microcontroller or Desktop). It is possible to integrate the functionalities of debugger probes like Segger J-Link (debugger probe not free unfortunately) or OpenOCD and the logging of a serial port into Eclipse. That way, the software can be developed without the need of various additional tools, which might not work on every OS (my personal philosophy: coding for microcontrollers should be (almost) as convenient as coding for Desktop applications). GNU Make is used as the build system for the software. A lot of work went into making the Makefiles readable to allow for easy tweaking. The project can be developed on Linux and on Windows, as long as the ARM toolchain is installed.\nFully featured MCU development environment in Eclipse\nI worked with a specific framework designed for small satellite missions called the Flight Software Framework. It was initially designed and created by the Institute of Space Systems (IRS) in Stuttgart for the mission Flying Laptop, which has been launched and is still operational. Using this framework saves a lot of work for small satellite mission software developers, for example by providing powerful abstraction layers for different operating systems, building blocks for common components like devices (sensors or other microcontrollers) and controllers (attitude or thermal controllers) and building blocks to enable telemetry and telecommand handling. Keeping the recent developments in space (New Space, Miniaturization, Cubesats..) in mind, there will propably be even more small satellites in the future and the need to shorten the development cycles for satellite software. The flight software framework is based on C++, which has become more common in the space sector recently. Still, a lot of (new) flight software is still based on C. A lot of the myths surrounding C++ in the context of embedded systems (code bloat, slow..) have been disproven and the language offers excellent tools to write safe code and to model the architecture of systems in the code, using the best capabilities of object oriented programming.\nThe device handlers I programmed are based on the FSFW template class DeviceHandlerBase. A template class takes care of a lot of generic code and expects the developer to implement abstract functions to model the unique device. There are certain common functions each (space) device handler needs:\nModes: Needed alter behaviour, for example some devices are off for certain satellite modes. Health state: For example to perform restarts when necessary. Commandability: It should be possible to command the device handler from Ground. The device should also be able to generate telemtry. Communication Interface: The device needs to talk to the respective sensor or microcontroller, using a data bus like SPI or UART (e.g. RS232) Power Switching: The device handler has to be able to turn a device off or on, using components of the power subsystem (EPS). Implementing the template class properly is a lot more work than simply making the sensor work on something like a Raspberry Pi or an Arduino but there is a huge advantage of going through the work of implementing the template class. All of those important functions that were mentioned above are more or less taken care of, which avoids boilerplate code. It should be noted that the SOURCE project, which is only a 3U cubesat, contains 4 microcontrollers, two FPGAs and more than 40 sensors (well, 20+ of those are temperature sensor which use the same device handler of course..), so any way to save rewriting generic code is very convenient. Furthermore, the device handlers offer a powerful decoupling mechanism by moving the API calls to the used communication bus into a different class, which is passed to the device handler. The result is that the device handlers only include the logic to handle the devices while the task of calling communication drivers of the hardware is transferred to the communication interface. This is especially nice for devices which can communicate with mulitple communication buses or where the configuration of the used bus only differs slightly (other SPI slave select, different I2C address..).\nIn these difficult times, it is of course better to work for home. After procuring the hardware from the institute, there was the task of setting up the hardware. I focused on two device handlers in particular: The ThermalSensorHandler, which took care of handling a MAX31865 Resistance-to-Digial converter, which in turn was connected to a Pt1000 thermal resistor, and the GyroHandler which handled a BMG250 MEMS gyroscope. Both sensors were soldered on a housekeeping board engineering model (I’d like to thank Jens Polzin, who is designing this board), which also contains sun sensors and SPI slave select expanders (decoders). The two following pictures show the set-up. The large board on the left is the AT91SAM9G20-EK development board, which has the same chip as the iOBC, which is the on-board computer of the SOURCE project.\nGeneral setup with the AT91SAM9G20-EK development board\nHousekeeping board prototype (engineering model) with various sensors\nThe sensors are generally read and configured by reading certain registers, according to the sensors’ datasheet. The basic test for the gyro involved taking the housekeeping board (HKB) and rotating it in both directions around every the X, Y and Z axis (kind of like a model airplane). It was also validated that the sensor values show the correct sign when rotating around a certain axis. The basic test for the thermal sensor handler included verifying the approximated temperature (room temperature) and checking whether it rises to 30-31 °C when touching the PT1000 sensor with my fingers.\nBoth device handlers have a start-up sequence which involves configuring the sensor and putting it into a state to perform poll the sensor properly. To perform all the initialization and configuration steps sequentially, an internal state machine is used. The usage of this state machine can be seen throughout the device handler code. The sequence of the device initialization is specified in the doStartUp abstract function implementation. The specification of the actual commands for start-up, mode transitions or shut-down sequences is specified in the function buildTransitionDeviceCommand (for simple sensors, this will usually only include the start-up sequence). When the configuration is complete, the device enters the MODE_NORMAL or MODE_ON mode and is ready to poll data. The commands for this nominal operation mode are specified in buildNormalDeviceCommand. buildCommandFromCommand is used to specify commands from external commands (for example, commands coming from ground or from another software component) but is also used by the other command building functions to avoid duplicate code. The functions scanForReply and interpretDeviceReply are used to analyse the sensor data and store it into the local datapool for either downlink operation as housekeeping data or for usage by other software components.\nOn a microcontroller, the print functions generally have to be redirected to a UART peripheral to be sent to the host computer for display. This is used for the AT91. A sample output is show, which shows the two sensors being polled regularly.\nEclipse internal serial console, showing debug output from the AT91\nI also started to work on a CoreController component, which takes care of monitoring the on-board computer itself. As a first step, I also took all necessary steps to enable communication with the iOBC on-board computer in the clean room of the IRS in Stuttgart. The iOBC engineering model (EM), being a rather expensive piece of hardware which is only available once, will be installed in the clean room and later be integrated into the flatsat, which is one of the most important testing platforms for the satellites and basically includes all the satellites component on a table wired together for testing. Of course, going to the clean room each time just to develop software is a lot of hassle. Therefore, remote development was set-up and is possible via Eclipse and RemoteGDB.\nOn-board computer iOBC engineering model in the clean room The core controller will take care of monitoring the supervisor, which in turn generates voltage and temperature values of the OBC. It will also take care of monitoring all running tasks. Readers unfamiliar with embedded programming and real-time operating systems propably still understand the concept of threads, which are used extensively on desktop systems. Even though the OBC only has one core, it is possible to perform apparent multitasking by using a scheduler, which is the core component of a real-time operating system (RTOS). The most common ones for space applications among others are FreeRTOS, RTEMS and Linux. The FSFW offers abstraction layers for all of them and FreeRTOS was chosen for SOURCE because the provided driver functions by the OBC manufacturer also use FreeRTOS. The Controller uses the FreeRTOS API to monitor the stack usage of programs, and generate general CPU statistics and downlink them (in CSV format).\nFreeRTOS Task Statistics printed out\nAnother important task of the core controller is the scrubbing of non-volatile memories on the on-board computer. Space is a hostile environment, and the strong radiation can cause bit flips in the memories, which is also called Single-Event-Upset (SEU). Therefore, a lot of space-grade hardware features advanced error control code (ECC) to correct those anomalies. The OBC of SOURCE does not feature hardware ECC, but it is possible to implement software ECC, for example by using the Hamming Code, which is able to correct one bitflip recognize two bitflips per 256 bytes. The hamming code will be generated on ground and written (or uploaded) to the non-volatile memory. It will then be used to regularly check the binaries in the non-volatile memories for bitflips. This task, which is called scrubbing, will also be performed by the core controller.\nA schematic of the software architecture was created with the graph software yEd to visualize it. This software schematic is the most useful document to show the software architecture in a brief format which is also accessible for other subsystem and stakeholders which are interested in the success of the project. It also exists in similar form to visualize the architecture of the whole system (in therms of hardware).\nSOURCE Software Schematic\n","wordCount":"1946","inLanguage":"en","datePublished":"2021-12-14T19:29:58+01:00","dateModified":"2023-10-03T23:12:57+02:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://robamu.github.io/blog/gsoc-post/"},"publisher":{"@type":"Organization","name":"hi, I am robin","logo":{"@type":"ImageObject","url":"https://robamu.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://robamu.github.io/ accesskey=h title="hi, I am robin (Alt + H)">hi, I am robin</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://robamu.github.io/ title=Home><span>Home</span></a></li><li><a href=https://robamu.github.io/projects/ title=Projects><span>Projects</span></a></li><li><a href=https://robamu.github.io/blog/ title=Blog><span>Blog</span></a></li><li><a href=https://robamu.github.io/contact/ title=Contact><span>Contact</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Throwback - GSoC 2020 | Device handler development for the SOURCE project</h1><div class=post-meta><span title='2021-12-14 19:29:58 +0100 +0100'>December 14, 2021</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;<span id=0aaeb4c67fdf1a9d18bd2f74b481f843 title=Views>? Views</span>
<script>var r=new XMLHttpRequest;r.addEventListener("load",function(){document.getElementById("0aaeb4c67fdf1a9d18bd2f74b481f843").innerHTML=JSON.parse(this.responseText).count_unique+" Views"}),r.open("GET","https://robamu.goatcounter.com/counter/"+encodeURIComponent("/blog/gsoc-post/".replace(/(\/)?$/,""))+".json"),r.send()</script></div></header><div class=post-content><p>This is an adapted version of a blog post initially posted
<a href="https://aerospaceresearch.net/?p=1912">on Wordpress</a> as part of my GSoC project. It&rsquo;s a perfect
way for me to set up my own first blog which is based on
<a href=https://youngkin.github.io/post/createafreeblogsite/>this excellent guide</a>.</p><p>At that point of time, I was an aerospace engineer doing my graduate studies at the University
of Stuttgart. I&rsquo;m still active in the small satellite society <a href=https://www.ksat-stuttgart.de/en/>KSat</a>
but I am doing more of a supporting role now that I started working the University as a PhD student.</p><p>The domain of my work was and still is embedded programming in C++. The most simple explanation of
my work would be that I programmed the handler software for sensors and the on-board computer
itself. The source code is located on the <a href=https://git.ksat-stuttgart.de/source/sourceobsw>gitlab server of
KSat</a>. The extensive README provides instructions
how to make the Linux version of the software work and how to setup Eclipse properly to allow
convenient microcontroller development. It should be noted that the device handlers were tested
on a microcontroller with FreeRTOS as the operating system. It has been really fascinating to
learn about different types of sensors and their interfaces. Of course, my work included more
than just making a few sensors work with something like an Arduino.</p><p>A lot of work went into making microcontroller development as convenient as possible while also
staying free and open-source. The used development environment is very much in the spirit of
open-source: Eclipse was used as an IDE and the software for the target on-board computer is
generated using the free ARM toolchain. The used framework is also open source and it is possible
to compile the software for Linux as well (Microcontroller or Desktop). It is possible to
integrate the functionalities of debugger probes like Segger J-Link
(debugger probe not free unfortunately) or OpenOCD and the logging of a serial port into Eclipse.
That way, the software can be developed without the need of various additional tools, which might
not work on every OS (my personal philosophy: coding for microcontrollers should be (almost) as
convenient as coding for Desktop applications). GNU Make is used as the build system for the
software. A lot of work went into making the Makefiles readable to allow for easy tweaking.
The project can be developed on Linux and on Windows, as long as the ARM toolchain is installed.</p><center><figure><img loading=lazy src=/img/gsoc-post/eclipse.png alt="Development board setup"><figcaption><p>Fully featured MCU development environment in Eclipse</p></figcaption></figure></center><p>I worked with a specific framework designed for small satellite missions called the <a href=https://egit.irs.uni-stuttgart.de/fsfw/fsfw>Flight
Software Framework</a>. It was initially
designed and created by the Institute of Space Systems (IRS) in Stuttgart for the mission
Flying Laptop, which has been launched and is still operational. Using this framework saves a
lot of work for small satellite mission software developers, for example by providing powerful
abstraction layers for different operating systems, building blocks for common components like
devices (sensors or other microcontrollers) and controllers (attitude or thermal controllers) and
building blocks to enable telemetry and telecommand handling. Keeping the recent developments in
space (New Space, Miniaturization, Cubesats..) in mind, there will propably be even more small
satellites in the future and the need to shorten the development cycles for satellite software.
The flight software framework is based on C++, which has become more common in the space sector
recently. Still, a lot of (new) flight software is still based on C. A lot of the myths
surrounding C++ in the context of embedded systems (code bloat, slow..) have been disproven and
the language offers excellent tools to write safe code and to model the architecture of systems
in the code, using the best capabilities of object oriented programming.</p><p>The device handlers I programmed are based on the FSFW template class DeviceHandlerBase.
A <a href=https://en.wikipedia.org/wiki/Template_method_pattern>template class</a> takes care of a lot of
generic code and expects the developer to implement abstract functions to model the unique device.
There are certain common functions each (space) device handler needs:</p><ol><li>Modes: Needed alter behaviour, for example some devices are off for certain satellite modes.</li><li>Health state: For example to perform restarts when necessary.</li><li>Commandability: It should be possible to command the device handler from Ground. The device
should also be able to generate telemtry.</li><li>Communication Interface: The device needs to talk to the respective sensor or microcontroller,
using a data bus like SPI or UART (e.g. RS232)</li><li>Power Switching: The device handler has to be able to turn a device off or on, using components
of the power subsystem (EPS).</li></ol><p>Implementing the template class properly is a lot more work than simply making the sensor work on
something like a Raspberry Pi or an Arduino but there is a huge advantage of going through the work
of implementing the template class. All of those important functions that were mentioned above are
more or less taken care of, which avoids boilerplate code. It should be noted that the SOURCE
project, which is only a 3U cubesat, contains 4 microcontrollers, two FPGAs and more than 40
sensors (well, 20+ of those are temperature sensor which use the same device handler of course..),
so any way to save rewriting generic code is very convenient. Furthermore, the device handlers
offer a powerful decoupling mechanism by moving the API calls to the used communication bus into
a different class, which is passed to the device handler. The result is that the device handlers
only include the logic to handle the devices while the task of calling communication drivers of
the hardware is transferred to the communication interface. This is especially nice for devices
which can communicate with mulitple communication buses or where the configuration of the used
bus only differs slightly (other SPI slave select, different I2C address..).</p><p>In these difficult times, it is of course better to work for home. After procuring the hardware
from the institute, there was the task of setting up the hardware. I focused on two device handlers
in particular: The ThermalSensorHandler, which took care of handling a
MAX31865 Resistance-to-Digial converter, which in turn was connected to a Pt1000 thermal resistor,
and the GyroHandler which handled a BMG250 MEMS gyroscope. Both sensors were soldered on a
housekeeping board engineering model (I&rsquo;d like to thank Jens Polzin, who is designing this board),
which also contains sun sensors and SPI slave select expanders (decoders). The two following
pictures show the set-up. The large board on the left is the AT91SAM9G20-EK development board,
which has the same chip as the iOBC, which is the on-board computer of the SOURCE project.</p><center><figure><img loading=lazy src=/img/gsoc-post/dev-board-setup.jpg alt="Development board setup"><figcaption><p>General setup with the AT91SAM9G20-EK development board</p></figcaption></figure></center><center><figure><img loading=lazy src=/img/gsoc-post/hkb-board.jpg alt="HKB board"><figcaption><p>Housekeeping board prototype (engineering model) with various sensors</p></figcaption></figure></center><p>The sensors are generally read and configured by reading certain registers, according to the
sensors&rsquo; datasheet. The basic test for the gyro involved taking the housekeeping board (HKB)
and rotating it in both directions around every the X, Y and Z axis (kind of like a model airplane).
It was also validated that the sensor values show the correct sign when rotating around a
certain axis. The basic test for the thermal sensor handler included verifying the approximated
temperature (room temperature) and checking whether it rises to 30-31 °C when touching the
PT1000 sensor with my fingers.</p><p>Both device handlers have a start-up sequence which involves configuring the sensor and putting
it into a state to perform poll the sensor properly. To perform all the initialization and
configuration steps sequentially, an internal state machine is used. The usage of this state
machine can be seen throughout the device handler code. The sequence of the device initialization
is specified in the <code>doStartUp</code> abstract function implementation. The specification of the actual
commands for start-up, mode transitions or shut-down sequences is specified in the function
<code>buildTransitionDeviceCommand</code> (for simple sensors, this will usually only include the
start-up sequence). When the configuration is complete, the device enters the <code>MODE_NORMAL</code> or
<code>MODE_ON</code> mode and is ready to poll data. The commands for this nominal operation mode are
specified in <code>buildNormalDeviceCommand</code>. <code>buildCommandFromCommand</code> is used to specify commands
from external commands (for example, commands coming from ground or from another software
component) but is also used by the other command building functions to avoid duplicate code.
The functions <code>scanForReply</code> and <code>interpretDeviceReply</code> are used to analyse the sensor data and
store it into the local datapool for either downlink operation as housekeeping data or for usage
by other software components.</p><p>On a microcontroller, the print functions generally have to be redirected to a UART peripheral
to be sent to the host computer for display. This is used for the AT91. A sample output is show,
which shows the two sensors being polled regularly.</p><center><figure><img loading=lazy src=/img/gsoc-post/eclipse_console.png alt="Development board setup"><figcaption><p>Eclipse internal serial console, showing debug output from the AT91</p></figcaption></figure></center><p>I also started to work on a CoreController component, which takes care of monitoring the on-board
computer itself. As a first step, I also took all necessary steps to enable communication with the
iOBC on-board computer in the clean room of the IRS in Stuttgart. The iOBC engineering model (EM),
being a rather expensive piece of hardware which is only available once, will be installed in the
clean room and later be integrated into the flatsat, which is one of the most important testing
platforms for the satellites and basically includes all the satellites component on a table wired
together for testing. Of course, going to the clean room each time just to develop software is a
lot of hassle. Therefore, remote development was set-up and is possible via Eclipse and RemoteGDB.</p><p><figure><img src=/img/gsoc-post/iOBC_scaled.jpg alt="On-board computer iOBC engineering model in the clean room
"><figcaption>On-board computer iOBC engineering model in the clean room</figcaption></figure></p><p>The core controller will take care of monitoring the supervisor, which in turn generates voltage
and temperature values of the OBC. It will also take care of monitoring all running tasks. Readers
unfamiliar with embedded programming and real-time operating systems propably still understand the
concept of threads, which are used extensively on desktop systems. Even though the OBC only has
one core, it is possible to perform apparent multitasking by using a scheduler, which is the core
component of a real-time operating system (RTOS). The most common ones for space applications
among others are FreeRTOS, RTEMS and Linux. The FSFW offers abstraction layers for all of them and
FreeRTOS was chosen for SOURCE because the provided driver functions by the OBC manufacturer also
use FreeRTOS. The Controller uses the FreeRTOS API to monitor the stack usage of programs, and
generate general CPU statistics and downlink them (in CSV format).</p><center><figure><img loading=lazy src=/img/gsoc-post/TaskStats.png alt="Development board setup"><figcaption><p>FreeRTOS Task Statistics printed out</p></figcaption></figure></center><p>Another important task of the core controller is the scrubbing of non-volatile memories on the
on-board computer. Space is a hostile environment, and the strong radiation can cause bit flips
in the memories, which is also called Single-Event-Upset (SEU). Therefore, a lot of space-grade
hardware features advanced error control code (ECC) to correct those anomalies. The OBC of SOURCE
does not feature hardware ECC, but it is possible to implement software ECC, for example by using
the <a href=https://en.wikipedia.org/wiki/Hamming_code>Hamming Code</a>, which is able to correct one bitflip
recognize two bitflips per 256 bytes. The hamming code will be generated on ground and written
(or uploaded) to the non-volatile memory. It will then be used to regularly check the binaries in
the non-volatile memories for bitflips. This task, which is called scrubbing, will also be
performed by the core controller.</p><p>A schematic of the software architecture was created with the graph software yEd to visualize it.
This software schematic is the most useful document to show the software architecture in a brief
format which is also accessible for other subsystem and stakeholders which are interested in the
success of the project. It also exists in similar form to visualize the architecture of the whole
system (in therms of hardware).</p><center><figure><img loading=lazy src=/img/gsoc-post/software_schematic.png alt="Development board setup"><figcaption><p>SOURCE Software Schematic</p></figcaption></figure></center></div><footer class=post-footer><ul class=post-tags><li><a href=https://robamu.github.io/tags/gsoc/>Gsoc</a></li><li><a href=https://robamu.github.io/tags/device-handler/>Device-Handler</a></li><li><a href=https://robamu.github.io/tags/sensors/>Sensors</a></li><li><a href=https://robamu.github.io/tags/eclipse/>Eclipse</a></li></ul><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Throwback - GSoC 2020 | Device handler development for the SOURCE project on x" href="https://x.com/intent/tweet/?text=Throwback%20-%20GSoC%202020%20%7c%20Device%20handler%20development%20for%20the%20SOURCE%20project&amp;url=https%3a%2f%2frobamu.github.io%2fblog%2fgsoc-post%2f&amp;hashtags=gsoc%2cdevice-handler%2csensors%2ceclipse"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Throwback - GSoC 2020 | Device handler development for the SOURCE project on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2frobamu.github.io%2fblog%2fgsoc-post%2f&amp;title=Throwback%20-%20GSoC%202020%20%7c%20Device%20handler%20development%20for%20the%20SOURCE%20project&amp;summary=Throwback%20-%20GSoC%202020%20%7c%20Device%20handler%20development%20for%20the%20SOURCE%20project&amp;source=https%3a%2f%2frobamu.github.io%2fblog%2fgsoc-post%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Throwback - GSoC 2020 | Device handler development for the SOURCE project on reddit" href="https://reddit.com/submit?url=https%3a%2f%2frobamu.github.io%2fblog%2fgsoc-post%2f&title=Throwback%20-%20GSoC%202020%20%7c%20Device%20handler%20development%20for%20the%20SOURCE%20project"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Throwback - GSoC 2020 | Device handler development for the SOURCE project on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2frobamu.github.io%2fblog%2fgsoc-post%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Throwback - GSoC 2020 | Device handler development for the SOURCE project on whatsapp" href="https://api.whatsapp.com/send?text=Throwback%20-%20GSoC%202020%20%7c%20Device%20handler%20development%20for%20the%20SOURCE%20project%20-%20https%3a%2f%2frobamu.github.io%2fblog%2fgsoc-post%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Throwback - GSoC 2020 | Device handler development for the SOURCE project on telegram" href="https://telegram.me/share/url?text=Throwback%20-%20GSoC%202020%20%7c%20Device%20handler%20development%20for%20the%20SOURCE%20project&amp;url=https%3a%2f%2frobamu.github.io%2fblog%2fgsoc-post%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Throwback - GSoC 2020 | Device handler development for the SOURCE project on ycombinator" href="https://news.ycombinator.com/submitlink?t=Throwback%20-%20GSoC%202020%20%7c%20Device%20handler%20development%20for%20the%20SOURCE%20project&u=https%3a%2f%2frobamu.github.io%2fblog%2fgsoc-post%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//https-robamu-github-io.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></article></main><script data-goatcounter=https://robamu.goatcounter.com/count async src=//gc.zgo.at/count.js></script><footer class=footer><span>&copy; 2025 <a href=https://robamu.github.io/>hi, I am robin</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>