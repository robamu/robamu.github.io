<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Rust driver for the 10-bit MAX11619 ADCs | hi, I am robin</title>
<meta name=keywords content="rust,driver,adc,max11619"><meta name=description content="In my last blog post, I described how I set up a
small Rust ecosystem for the Vorago REB1 development board. This development board also
has a MAX11619 10-bit ADC device by Maxim devices. I thought this was a good opportunity
to develop my first device driver crate because there isn&rsquo;t one for this device yet.
The REB1 development board also has a 2K potentiometer connected directly to a channel of the ADC
which makes testing convenient."><meta name=author content><link rel=canonical href=https://robamu.github.io/blog/max11619-driver-rust/><link crossorigin=anonymous href=/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://robamu.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://robamu.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://robamu.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://robamu.github.io/apple-touch-icon.png><link rel=mask-icon href=https://robamu.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://robamu.github.io/blog/max11619-driver-rust/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://robamu.github.io/blog/max11619-driver-rust/"><meta property="og:site_name" content="hi, I am robin"><meta property="og:title" content="Rust driver for the 10-bit MAX11619 ADCs"><meta property="og:description" content="In my last blog post, I described how I set up a small Rust ecosystem for the Vorago REB1 development board. This development board also has a MAX11619 10-bit ADC device by Maxim devices. I thought this was a good opportunity to develop my first device driver crate because there isn’t one for this device yet.
The REB1 development board also has a 2K potentiometer connected directly to a channel of the ADC which makes testing convenient."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="blog"><meta property="article:published_time" content="2021-12-16T22:51:15+01:00"><meta property="article:modified_time" content="2023-10-03T19:46:45+02:00"><meta property="article:tag" content="Rust"><meta property="article:tag" content="Driver"><meta property="article:tag" content="Adc"><meta property="article:tag" content="Max11619"><meta name=twitter:card content="summary"><meta name=twitter:title content="Rust driver for the 10-bit MAX11619 ADCs"><meta name=twitter:description content="In my last blog post, I described how I set up a
small Rust ecosystem for the Vorago REB1 development board. This development board also
has a MAX11619 10-bit ADC device by Maxim devices. I thought this was a good opportunity
to develop my first device driver crate because there isn&rsquo;t one for this device yet.
The REB1 development board also has a 2K potentiometer connected directly to a channel of the ADC
which makes testing convenient."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"","item":"https://robamu.github.io/blog/"},{"@type":"ListItem","position":2,"name":"Rust driver for the 10-bit MAX11619 ADCs","item":"https://robamu.github.io/blog/max11619-driver-rust/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Rust driver for the 10-bit MAX11619 ADCs","name":"Rust driver for the 10-bit MAX11619 ADCs","description":"In my last blog post, I described how I set up a small Rust ecosystem for the Vorago REB1 development board. This development board also has a MAX11619 10-bit ADC device by Maxim devices. I thought this was a good opportunity to develop my first device driver crate because there isn\u0026rsquo;t one for this device yet.\nThe REB1 development board also has a 2K potentiometer connected directly to a channel of the ADC which makes testing convenient.\n","keywords":["rust","driver","adc","max11619"],"articleBody":"In my last blog post, I described how I set up a small Rust ecosystem for the Vorago REB1 development board. This development board also has a MAX11619 10-bit ADC device by Maxim devices. I thought this was a good opportunity to develop my first device driver crate because there isn’t one for this device yet.\nThe REB1 development board also has a 2K potentiometer connected directly to a channel of the ADC which makes testing convenient.\nSetup with a Digilent Oscilloscope\nBoard schematic for ADC and Potentiometer\nFrom the schematic, I saw that the CNVST pin is not connected so I could not really test any of the ADC functions using that pin, but everything else should work.\nI used the knowledge I gained from programming type-safe APIs for the VA108xx HAL and BSP to code a type-safe API for the MAX116xx device. The ADC device has different modes and configuration options to specify the clock source and the voltage reference source. Some examples:\nUse the external SPI clock for acquisiton and conversion and use an external voltage reference Use the SPI interface to start the acquisiton but use the internal oscillator for the conversions. The End-Of-Conversion (EOC) pin is used to check whether the conversion is complete. Use an internal voltage reference which is off after acquisition, so a 65 microseconds wake-up delay becomes necessary. There are a lot other configurations, and the Rust typesystem prevents using a wrong API for a given configuration. Max116xx10Bit is now initially created as an externally clocked device with an external voltage reference. This is also a valid configuration to read the ADC on the REB1 board, as the reference is pin is tied to the system voltage.\nIf another configuration is desired, the device struct needs to be converted into a different configuration using the into_*() API common to Rust. The driver docs specify some of these functions. To achieve the second configuration shown above, one would use the into_int_clkd_int_timed_through_ser_if_with_wakeup function.\nThere are also some helper constructor functions for each ADC family derivative. Some of these derivatives have different channel numbers, and the constructors set the highest channel number correct automatically, which can prevent some errors like specifying an invalid channel number as well.\nThis is the example function to use the first shown configuration and using different API options to read the channels. The full example can be found here. Provided that a JLinkGDBServer is running, flashing the software can be done with this simple command:\ncargo run --example max11619-adc --release I also used release here because I checked the correct timing and an optimized build is best for that.\n/// Use the SPI clock as the conversion clock fn adc_example_externally_clocked(spi: SpiBase\u003cSPIB\u003e, mut delay: Delay) -\u003e ! { let mut adc = max11619_externally_clocked_no_wakeup(spi) .expect(\"Creating externally clocked MAX11619 device failed\"); if READ_MODE == ReadMode::AverageN { adc.averaging( AveragingConversions::FourConversions, AveragingResults::FourResults, ) .expect(\"Error setting up averaging register\"); } let mut cmd_buf: [u8; 32] = [0; 32]; let mut counter = 0; loop { rprintln!(\"-- Measurement {} --\", counter); match READ_MODE { ReadMode::Single =\u003e { rprintln!(\"Reading single potentiometer channel\"); let pot_val = adc .read_single_channel(\u0026mut cmd_buf, POTENTIOMETER_CHANNEL) .expect(\"Creating externally clocked MAX11619 ADC failed\"); rprintln!(\"Single channel read:\"); rprintln!(\"\\tPotentiometer value: {}\", pot_val); } ReadMode::Multiple =\u003e { let mut res_buf: [u16; 4] = [0; 4]; adc.read_multiple_channels_0_to_n( \u0026mut cmd_buf, \u0026mut res_buf.iter_mut(), POTENTIOMETER_CHANNEL, ) .expect(\"Multi-Channel read failed\"); print_res_buf(\u0026res_buf); } ReadMode::MultipleNToHighest =\u003e { let mut res_buf: [u16; 2] = [0; 2]; adc.read_multiple_channels_n_to_highest( \u0026mut cmd_buf, \u0026mut res_buf.iter_mut(), AN2_CHANNEL, ) .expect(\"Multi-Channel read failed\"); rprintln!(\"Multi channel read from 2 to 3:\"); rprintln!(\"\\tAN2 value: {}\", res_buf[0]); rprintln!(\"\\tAN3 / Potentiometer value: {}\", res_buf[1]); } ReadMode::AverageN =\u003e { rprintln!(\"Scanning and averaging not possible for externally clocked mode\"); } } counter += 1; delay.delay_ms(500); } } There is also an example mode which uses the averaging functionality of the ADC. This can be used for something like filtering a noisy signal.\nThe SpiBase struct is VA10820 specific, but any SPI instance which implements the embedded-hal can be used to instantiate an ADC struct.\nADC channel output, AN1 tied to 3.3V\nI also checked the SPI signals to make fully sure that my the HAL SPI driver was correctly functioning concerning properties like timing. To check the signals directly, I was able to multiplex some pins to gain access to the SPI signals. Unfortunately, this did not really work for the MISO line, but the received values are definitely valid: When the pontentiometer is at the lowest resistance, the full system voltage is tied to the analog channel. For a 10-bit ADC, a value close to 2 to the power of 10 (1023) makes sense here. The Digilent Oscilloscope also has a really neat decoder function to analyze common peripherals.\nADC single readout signals\nFinally, I also checked whether the timing was correctly when using a mode with a 65 us wake-up delay after initiating the conversion by sending one byte:\nADC single readout signals with wake-up delay\nGood signals, and the RTT viewer was displaying correct ADC chanel values as well!\nI really like how Rust allows library and device driver developers to write safe APIs which can prevent a lot of errors at compile time. I think this has a lot of potential for satellite software development, where it is common to forbid certain operations for different software modes. Encoding something like that at compile time would make the software a lot safer.\nIn some of our projects, we also use the MAX1227 12-bit ADCs which have a lot of similarities to the MAX116xx 10-bit devices. I might look into writing a device driver crate for those as well soon.\n","wordCount":"932","inLanguage":"en","datePublished":"2021-12-16T22:51:15+01:00","dateModified":"2023-10-03T19:46:45+02:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://robamu.github.io/blog/max11619-driver-rust/"},"publisher":{"@type":"Organization","name":"hi, I am robin","logo":{"@type":"ImageObject","url":"https://robamu.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://robamu.github.io/ accesskey=h title="hi, I am robin (Alt + H)">hi, I am robin</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://robamu.github.io/ title=Home><span>Home</span></a></li><li><a href=https://robamu.github.io/projects/ title=Projects><span>Projects</span></a></li><li><a href=https://robamu.github.io/blog/ title=Blog><span>Blog</span></a></li><li><a href=https://robamu.github.io/sat-rs/book/ title="sat-rs book"><span>sat-rs book</span></a></li><li><a href=https://robamu.github.io/contact/ title=Contact><span>Contact</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Rust driver for the 10-bit MAX11619 ADCs</h1><div class=post-meta><span title='2021-12-16 22:51:15 +0100 +0100'>December 16, 2021</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;<span id=47c7ecc200b536ef55111f1eefce8f74 title=Views>? Views</span>
<script>var r=new XMLHttpRequest;r.addEventListener("load",function(){document.getElementById("47c7ecc200b536ef55111f1eefce8f74").innerHTML=JSON.parse(this.responseText).count_unique+" Views"}),r.open("GET","https://robamu.goatcounter.com/counter/"+encodeURIComponent("/blog/max11619-driver-rust/".replace(/(\/)?$/,""))+".json"),r.send()</script></div></header><div class=post-content><p>In my <a href=https://robamu.github.io/post/rust-ecosystem/>last blog post</a>, I described how I set up a
small Rust ecosystem for the Vorago REB1 development board. This development board also
has a MAX11619 10-bit ADC device by Maxim devices. I thought this was a good opportunity
to develop my first device driver crate because there isn&rsquo;t one for this device yet.</p><p>The REB1 development board also has a 2K potentiometer connected directly to a channel of the ADC
which makes testing convenient.</p><center><figure><img loading=lazy src=/img/max11619-driver/setup-rotated.jpg alt="Setup with a Digilent Oscilloscope"><figcaption><p>Setup with a Digilent Oscilloscope</p></figcaption></figure></center><center><figure><img loading=lazy src=/img/max11619-driver/pot-schem.png alt="Board schematic for ADC and Potentiometer"><figcaption><p>Board schematic for ADC and Potentiometer</p></figcaption></figure></center><p>From the schematic, I saw that the CNVST pin is not connected so I could not really test
any of the ADC functions using that pin, but everything else should work.</p><p>I used the knowledge I gained from programming type-safe APIs for the VA108xx HAL and BSP to
code a type-safe API for the MAX116xx device. The ADC device has different modes and configuration
options to specify the clock source and the voltage reference source. Some examples:</p><ol><li>Use the external SPI clock for acquisiton and conversion and use an external voltage reference</li><li>Use the SPI interface to start the acquisiton but use the internal oscillator for the conversions.
The End-Of-Conversion (EOC) pin is used to check whether the conversion is complete.
Use an internal voltage reference which is off after acquisition, so a 65 microseconds wake-up
delay becomes necessary.</li></ol><p>There are a lot other configurations, and the Rust typesystem prevents using a wrong API for a
given configuration. <a href=https://docs.rs/max116xx-10bit/latest/max116xx_10bit/struct.Max116xx10Bit.html><code>Max116xx10Bit</code></a>
is now initially created as an externally clocked device with an external voltage reference.
This is also a valid configuration to read the ADC on the REB1 board,
as the reference is pin is tied to the system voltage.</p><p>If another configuration is desired, the device struct needs to be converted into a different
configuration using the <code>into_*()</code> API common to Rust. The <a href=https://docs.rs/max116xx-10bit/latest/max116xx_10bit/>driver docs</a>
specify some of these functions. To achieve the second configuration shown above, one would
use the <a href=https://docs.rs/max116xx-10bit/latest/max116xx_10bit/struct.Max116xx10Bit.html#method.into_int_clkd_int_timed_through_ser_if_with_wakeup><code>into_int_clkd_int_timed_through_ser_if_with_wakeup</code>
</a>function.</p><p>There are also some helper constructor functions for each ADC family derivative. Some of these
derivatives have different channel numbers, and the constructors set the highest channel number
correct automatically, which can prevent some errors like specifying an invalid channel number
as well.</p><p>This is the example function to use the first shown configuration and using different API
options to read the channels. The full example can be found
<a href=https://egit.irs.uni-stuttgart.de/rust/vorago-reb1/src/branch/main/examples/max11619-adc.rs>here</a>.
Provided that a <code>JLinkGDBServer</code> is running, flashing the software can be done with this simple
command:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>cargo run --example max11619-adc --release
</span></span></code></pre></div><p>I also used <code>release</code> here because I checked the correct timing and an optimized build is best for
that.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rs data-lang=rs><span class=line><span class=cl><span class=sd>/// Use the SPI clock as the conversion clock
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=k>fn</span> <span class=nf>adc_example_externally_clocked</span><span class=p>(</span><span class=n>spi</span>: <span class=nc>SpiBase</span><span class=o>&lt;</span><span class=no>SPIB</span><span class=o>&gt;</span><span class=p>,</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>delay</span>: <span class=nc>Delay</span><span class=p>)</span><span class=w> </span>-&gt; <span class=o>!</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>adc</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>max11619_externally_clocked_no_wakeup</span><span class=p>(</span><span class=n>spi</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>.</span><span class=n>expect</span><span class=p>(</span><span class=s>&#34;Creating externally clocked MAX11619 device failed&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=no>READ_MODE</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>ReadMode</span>::<span class=n>AverageN</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>adc</span><span class=p>.</span><span class=n>averaging</span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>AveragingConversions</span>::<span class=n>FourConversions</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>AveragingResults</span>::<span class=n>FourResults</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>.</span><span class=n>expect</span><span class=p>(</span><span class=s>&#34;Error setting up averaging register&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>cmd_buf</span>: <span class=p>[</span><span class=kt>u8</span><span class=p>;</span><span class=w> </span><span class=mi>32</span><span class=p>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>[</span><span class=mi>0</span><span class=p>;</span><span class=w> </span><span class=mi>32</span><span class=p>];</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>counter</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>0</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>loop</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=fm>rprintln!</span><span class=p>(</span><span class=s>&#34;-- Measurement {} --&#34;</span><span class=p>,</span><span class=w> </span><span class=n>counter</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>match</span><span class=w> </span><span class=no>READ_MODE</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>ReadMode</span>::<span class=n>Single</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=fm>rprintln!</span><span class=p>(</span><span class=s>&#34;Reading single potentiometer channel&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=kd>let</span><span class=w> </span><span class=n>pot_val</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>adc</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=p>.</span><span class=n>read_single_channel</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>cmd_buf</span><span class=p>,</span><span class=w> </span><span class=no>POTENTIOMETER_CHANNEL</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=p>.</span><span class=n>expect</span><span class=p>(</span><span class=s>&#34;Creating externally clocked MAX11619 ADC failed&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=fm>rprintln!</span><span class=p>(</span><span class=s>&#34;Single channel read:&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=fm>rprintln!</span><span class=p>(</span><span class=s>&#34;</span><span class=se>\t</span><span class=s>Potentiometer value: {}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>pot_val</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>ReadMode</span>::<span class=n>Multiple</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>res_buf</span>: <span class=p>[</span><span class=kt>u16</span><span class=p>;</span><span class=w> </span><span class=mi>4</span><span class=p>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>[</span><span class=mi>0</span><span class=p>;</span><span class=w> </span><span class=mi>4</span><span class=p>];</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>adc</span><span class=p>.</span><span class=n>read_multiple_channels_0_to_n</span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>cmd_buf</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>res_buf</span><span class=p>.</span><span class=n>iter_mut</span><span class=p>(),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=no>POTENTIOMETER_CHANNEL</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>.</span><span class=n>expect</span><span class=p>(</span><span class=s>&#34;Multi-Channel read failed&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>print_res_buf</span><span class=p>(</span><span class=o>&amp;</span><span class=n>res_buf</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>ReadMode</span>::<span class=n>MultipleNToHighest</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>res_buf</span>: <span class=p>[</span><span class=kt>u16</span><span class=p>;</span><span class=w> </span><span class=mi>2</span><span class=p>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>[</span><span class=mi>0</span><span class=p>;</span><span class=w> </span><span class=mi>2</span><span class=p>];</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>adc</span><span class=p>.</span><span class=n>read_multiple_channels_n_to_highest</span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>cmd_buf</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>res_buf</span><span class=p>.</span><span class=n>iter_mut</span><span class=p>(),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=no>AN2_CHANNEL</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>.</span><span class=n>expect</span><span class=p>(</span><span class=s>&#34;Multi-Channel read failed&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=fm>rprintln!</span><span class=p>(</span><span class=s>&#34;Multi channel read from 2 to 3:&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=fm>rprintln!</span><span class=p>(</span><span class=s>&#34;</span><span class=se>\t</span><span class=s>AN2 value: {}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>res_buf</span><span class=p>[</span><span class=mi>0</span><span class=p>]);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=fm>rprintln!</span><span class=p>(</span><span class=s>&#34;</span><span class=se>\t</span><span class=s>AN3 / Potentiometer value: {}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>res_buf</span><span class=p>[</span><span class=mi>1</span><span class=p>]);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>ReadMode</span>::<span class=n>AverageN</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=fm>rprintln!</span><span class=p>(</span><span class=s>&#34;Scanning and averaging not possible for externally clocked mode&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>counter</span><span class=w> </span><span class=o>+=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>delay</span><span class=p>.</span><span class=n>delay_ms</span><span class=p>(</span><span class=mi>500</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>There is also an example mode which uses the averaging functionality of the ADC. This can be used
for something like filtering a noisy signal.</p><p>The <code>SpiBase&lt;SPIB></code> struct is VA10820 specific, but any SPI instance which implements the
<a href=https://docs.rs/embedded-hal/latest/embedded_hal/><code>embedded-hal</code></a> can be used to
instantiate an ADC struct.</p><center><figure><img loading=lazy src=/gif/max11619-driver/vor-pot.gif alt="Operating the potentiometer"></figure></center><center><figure><img loading=lazy src=/gif/max11619-driver/vor-rtt.gif alt="ADC channel output"><figcaption><p>ADC channel output, AN1 tied to 3.3V</p></figcaption></figure></center><p>I also checked the SPI signals to make fully sure that my the HAL SPI driver was correctly
functioning concerning properties like timing. To check the signals directly, I was able to
multiplex some pins to gain access to the SPI signals. Unfortunately, this did not really work for
the MISO line, but the received values are
definitely valid: When the pontentiometer is at the lowest resistance, the full system voltage
is tied to the analog channel. For a 10-bit ADC, a value close to 2 to the power of 10 (1023)
makes sense here. The Digilent Oscilloscope also has a really neat decoder function
to analyze common peripherals.</p><center><figure><img loading=lazy src=/img/max11619-driver/adc-single-read.png alt="ADC single read signal"><figcaption><p>ADC single readout signals</p></figcaption></figure></center><p>Finally, I also checked whether the timing was correctly when using a mode with a 65 us
wake-up delay after initiating the conversion by sending one byte:</p><center><figure><img loading=lazy src=/img/max11619-driver/adc-with-delay.png alt="ADC single readout signals with wake-up delay"><figcaption><p>ADC single readout signals with wake-up delay</p></figcaption></figure></center><p>Good signals, and the RTT viewer was displaying correct ADC chanel values as well!</p><p>I really like how Rust allows library and device driver developers to write safe APIs which can
prevent a lot of errors at compile time. I think this has a lot of potential for satellite
software development, where it is common to forbid certain operations for different software modes.
Encoding something like that at compile time would make the software a lot safer.</p><p>In some of our projects, we also use the <a href=https://www.maximintegrated.com/en/products/analog/data-converters/analog-to-digital-converters/MAX1227.html>MAX1227 12-bit ADCs
</a>which have a lot of similarities to the MAX116xx 10-bit devices. I might look into writing
a device driver crate for those as well soon.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://robamu.github.io/tags/rust/>Rust</a></li><li><a href=https://robamu.github.io/tags/driver/>Driver</a></li><li><a href=https://robamu.github.io/tags/adc/>Adc</a></li><li><a href=https://robamu.github.io/tags/max11619/>Max11619</a></li></ul><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Rust driver for the 10-bit MAX11619 ADCs on x" href="https://x.com/intent/tweet/?text=Rust%20driver%20for%20the%2010-bit%20MAX11619%20ADCs&amp;url=https%3a%2f%2frobamu.github.io%2fblog%2fmax11619-driver-rust%2f&amp;hashtags=rust%2cdriver%2cadc%2cmax11619"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Rust driver for the 10-bit MAX11619 ADCs on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2frobamu.github.io%2fblog%2fmax11619-driver-rust%2f&amp;title=Rust%20driver%20for%20the%2010-bit%20MAX11619%20ADCs&amp;summary=Rust%20driver%20for%20the%2010-bit%20MAX11619%20ADCs&amp;source=https%3a%2f%2frobamu.github.io%2fblog%2fmax11619-driver-rust%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Rust driver for the 10-bit MAX11619 ADCs on reddit" href="https://reddit.com/submit?url=https%3a%2f%2frobamu.github.io%2fblog%2fmax11619-driver-rust%2f&title=Rust%20driver%20for%20the%2010-bit%20MAX11619%20ADCs"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Rust driver for the 10-bit MAX11619 ADCs on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2frobamu.github.io%2fblog%2fmax11619-driver-rust%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Rust driver for the 10-bit MAX11619 ADCs on whatsapp" href="https://api.whatsapp.com/send?text=Rust%20driver%20for%20the%2010-bit%20MAX11619%20ADCs%20-%20https%3a%2f%2frobamu.github.io%2fblog%2fmax11619-driver-rust%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Rust driver for the 10-bit MAX11619 ADCs on telegram" href="https://telegram.me/share/url?text=Rust%20driver%20for%20the%2010-bit%20MAX11619%20ADCs&amp;url=https%3a%2f%2frobamu.github.io%2fblog%2fmax11619-driver-rust%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Rust driver for the 10-bit MAX11619 ADCs on ycombinator" href="https://news.ycombinator.com/submitlink?t=Rust%20driver%20for%20the%2010-bit%20MAX11619%20ADCs&u=https%3a%2f%2frobamu.github.io%2fblog%2fmax11619-driver-rust%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//https-robamu-github-io.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></article></main><script data-goatcounter=https://robamu.goatcounter.com/count async src=//gc.zgo.at/count.js></script><footer class=footer><span>&copy; 2025 <a href=https://robamu.github.io/>hi, I am robin</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>