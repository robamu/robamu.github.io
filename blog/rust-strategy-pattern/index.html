<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Implementing a TCP server for Space Applications in Rust using the Strategy Pattern | hi, I am robin</title>
<meta name=keywords content="rust,design-pattern,tcp,space"><meta name=description content="Even for space systems, TCP/IP is oftentimes an important component in some shape or form because
the majority of development might still occur on ground where an internet connection is still
available. The special thing about space is that instead of using newline and/or UTF-8 based
data, the data is generally in binary format and packet based. The most prevalent of the space
packet standards is probably the CCSDS Space Packet Protocol."><meta name=author content><link rel=canonical href=https://robamu.github.io/blog/rust-strategy-pattern/><link crossorigin=anonymous href=/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://robamu.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://robamu.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://robamu.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://robamu.github.io/apple-touch-icon.png><link rel=mask-icon href=https://robamu.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://robamu.github.io/blog/rust-strategy-pattern/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://robamu.github.io/blog/rust-strategy-pattern/"><meta property="og:site_name" content="hi, I am robin"><meta property="og:title" content="Implementing a TCP server for Space Applications in Rust using the Strategy Pattern"><meta property="og:description" content="Even for space systems, TCP/IP is oftentimes an important component in some shape or form because the majority of development might still occur on ground where an internet connection is still available. The special thing about space is that instead of using newline and/or UTF-8 based data, the data is generally in binary format and packet based. The most prevalent of the space packet standards is probably the CCSDS Space Packet Protocol."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="blog"><meta property="article:published_time" content="2023-09-29T15:17:13+02:00"><meta property="article:modified_time" content="2023-10-03T19:46:45+02:00"><meta property="article:tag" content="Rust"><meta property="article:tag" content="Design-Pattern"><meta property="article:tag" content="Tcp"><meta property="article:tag" content="Space"><meta name=twitter:card content="summary"><meta name=twitter:title content="Implementing a TCP server for Space Applications in Rust using the Strategy Pattern"><meta name=twitter:description content="Even for space systems, TCP/IP is oftentimes an important component in some shape or form because
the majority of development might still occur on ground where an internet connection is still
available. The special thing about space is that instead of using newline and/or UTF-8 based
data, the data is generally in binary format and packet based. The most prevalent of the space
packet standards is probably the CCSDS Space Packet Protocol."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"","item":"https://robamu.github.io/blog/"},{"@type":"ListItem","position":2,"name":"Implementing a TCP server for Space Applications in Rust using the Strategy Pattern","item":"https://robamu.github.io/blog/rust-strategy-pattern/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Implementing a TCP server for Space Applications in Rust using the Strategy Pattern","name":"Implementing a TCP server for Space Applications in Rust using the Strategy Pattern","description":"Even for space systems, TCP/IP is oftentimes an important component in some shape or form because the majority of development might still occur on ground where an internet connection is still available. The special thing about space is that instead of using newline and/or UTF-8 based data, the data is generally in binary format and packet based. The most prevalent of the space packet standards is probably the CCSDS Space Packet Protocol.\n","keywords":["rust","design-pattern","tcp","space"],"articleBody":"Even for space systems, TCP/IP is oftentimes an important component in some shape or form because the majority of development might still occur on ground where an internet connection is still available. The special thing about space is that instead of using newline and/or UTF-8 based data, the data is generally in binary format and packet based. The most prevalent of the space packet standards is probably the CCSDS Space Packet Protocol.\nTCP is always a tricky protocol when exchanging something like CCSDS space packets. UDP is generally a better fit because a packet can simply be exchanged as a datagram. However, there are special cases where TCP is simply more convenient, for example when using something like SSH tunneling, which would require some socat trickery to use UDP. Sometimes, we would also like to have the additional guarantees that TCP has in comparison to UDP.\nWhat I already have I already implemented a TCP server implementation for C++ which is able to exchange tightly packed CCSDS space packets. The only thing all CCSDS space packets have in common is a six byte header, shown in the following image:\nCCSDS space packet header\nThe Packet Identification field (Packet ID) can be used specifically as a start marker to detect packets from a raw bytestream. After detecting the start of a packet, the fifth and sixth byte can be used to know the size of the full packet. This still is not a perfect transport layer in my opinion, because it is still missing proper framing. However, with the assumption that TCP guarantees full data integrity and some robust CCSDS parsing, I am generally happy with this, as it allows to simply send and read possibly multiple CCSDS space packets in one go without any additional framing protocols on top.\nMoving to Rust I recently implemented a TCP server for the sat-rs Rust framework with the goal to have a similar behaviour as the C++ variant. Additionally, I also had to goal to allow more than just CCSDS space packets by using the COBS protocol as a generic framing mechanism. This would in theory also allow to exchange something like USLP frames.\nAfter implementing this second variant first, I quickly noticed that the first variant using COBS encoded packets would share a lot of common code with the first variant exchanging CCSDS space packets only. This is because the process of reading a bytestream and extracting frames from that bytestream using a certain parsing protocol is common for both variants. The same is also true for the telemetry sent back to a client: It might be necessary to apply some encoding logic on the raw packets before sending them, but other than that, the logic is the same.\nThe Strategy Pattern Coming from languages and projects which use object orientation heavily, my first thought was to use the template method pattern here. However, Rust does not allow inheritance, so I quickly determined that the strategy pattern would be the best fit here. If you do not know what the strategy pattern is, I recommend reading the article by Refactoring Guru. The following graph, which is taken from the article as well 1, shows the basic idea:\nThe Strategy Design Pattern\nThe strategy pattern allows to have a base algorithm with flexible adaption points which are called strategies. This pattern can be mapped on our problem and to Rust: The context object will be our generic TCP server which has some common logic to read TCs from a client and send back telemetry to the client. The Strategy interface is some trait which supplies all information required to parse telecommands from a raw bytestream or send telemetry back to the client. A concrete implementation would then for example be a COBS decoder object.\nThe generic TCP server The basic tasks of the generic TCP server object are the following:\nListen for TCP connections. If a client connects, accept the connection. Start reading the bytestream sent from the client until it is exhausted, or the used TC buffer is full. Exhausted means that the client stop sending telecommands (receiver timeout) or shuts down the writer side. If something was read from the client, start parsing for frames. This is where the strategy pattern comes in: I’d like the parsing algorithm to be something which can be different depending on which TC parsing strategy I am using, or more specifically, the strategy which I configured for that class. After a reader timeout or having read all packets, I also want to send back telemetry to the client. Here, I might have to apply custom protocols to the packets I want to send as well, so I want to apply an encoding algorithm depending on which TM strategy is used. After a bit of cleaning up, this is what the general structure of the primary connection handler looked like, using some pseudo code as well:\npub fn handle_next_connection( \u0026mut self, ) -\u003e Result\u003cConnectionResult, TcpTmtcError\u003cTmError, TcError\u003e\u003e { // This contains some context data about the handled connection, e.g. amount of handled TC // and TM packets let mut connection_result = ConnectionResult::default(); let mut current_write_idx; let mut next_write_idx = 0; let (mut stream, addr) = self.tcp_listener.accept()?; stream.set_nonblocking(true)?; connection_result.addr = Some(addr); current_write_idx = next_write_idx; loop { let read_result = stream.read(\u0026mut self.tc_buffer[current_write_idx..]); match read_result { Ok(0) =\u003e { // Connection closed by client. If any TC was read, parse for complete packets. // After that, break the outer loop. if current_write_idx \u003e 0 { self.tc_handler.handle_tc_parsing(...) } break; } Ok(read_len) =\u003e { current_write_idx += read_len; // TC buffer is full, we must parse for complete packets now. if current_write_idx == self.tc_buffer.capacity() { self.tc_handler.handle_tc_parsing(...) current_write_idx = next_write_idx; } } Err(e) =\u003e match e.kind() { // As per [TcpStream::set_read_timeout] documentation, this should work for // both UNIX and Windows. std::io::ErrorKind::WouldBlock | std::io::ErrorKind::TimedOut =\u003e { self.tc_handler.handle_tc_parsing(...) current_write_idx = next_write_idx; if !self.tm_handler.handle_tm_sending(...)? { // No TC read, no TM was sent, but the client has not disconnected. // Perform an inner delay to avoid burning CPU time. thread::sleep(self.base.inner_loop_delay); } } _ =\u003e { return Err(TcpTmtcError::Io(e)); } }, } } self.tm_handler.handle_tm_sending(...)?; Ok(connection_result) } The Strategy Interface and Implementation In languages like C++ or Java, the strategy is generally an abstract interface specification which is then implemented in form of concrete strategy objects. These concrete objects are then passed to the context object which expects a concrete strategy as the adaption point for users. In Rust, we can do these in a similar way: We specify an interface as a trait which provides all information necessary to perform the parsing of telecommands or the encoding of telemetry. In the example above, the tc_parser and tm_handler objects are either trait objects member or generic members of the generic TCP server which implement the corresponding strategy traits.\nAfter determining the necessary information for implementing the strategy, I have the following traits:\n/// Generic parser abstraction for an object which can parse for telecommands given a raw /// bytestream received from a TCP socket and send them to a generic [ReceivesTc] telecommand /// receiver. This allows different encoding schemes for telecommands. pub trait TcpTcParser\u003cTmError, TcError\u003e { fn handle_tc_parsing( \u0026mut self, tc_buffer: \u0026mut [u8], tc_receiver: \u0026mut (impl ReceivesTc\u003cError = TcError\u003e + ?Sized), conn_result: \u0026mut ConnectionResult, current_write_idx: usize, next_write_idx: \u0026mut usize, ) -\u003e Result\u003c(), TcpTmtcError\u003cTmError, TcError\u003e\u003e; } /// Generic sender abstraction for an object which can pull telemetry from a given TM source /// using a [TmPacketSource] and then send them back to a client using a given [TcpStream]. /// The concrete implementation can also perform any encoding steps which are necessary before /// sending back the data to a client. pub trait TcpTmSender\u003cTmError, TcError\u003e { fn handle_tm_sending( \u0026mut self, tm_buffer: \u0026mut [u8], tm_source: \u0026mut (impl TmPacketSource\u003cError = TmError\u003e + ?Sized), conn_result: \u0026mut ConnectionResult, stream: \u0026mut TcpStream, ) -\u003e Result\u003cbool, TcpTmtcError\u003cTmError, TcError\u003e\u003e; } Also note that we use another set of traits to allow passing found TC packets to a user using a generic ReceivesTcCore base trait. We also use a TmPacketSourceCore base trait as the generic trait for user supplied telemetry packets. These also fit into the strategy pattern by allowing the user to modify TC forwarding and TM specification through a generic contract.\nWe can now use generics to specify the strategy for the generic object. The generic TCP server class then looks like this:\npub struct TcpTmtcGenericServer\u003c TmError, TcError, TmSource: TmPacketSource\u003cError = TmError\u003e, TcReceiver: ReceivesTc\u003cError = TcError\u003e, TmSender: TcpTmSender\u003cTmError, TcError\u003e, TcParser: TcpTcParser\u003cTmError, TcError\u003e, \u003e { pub(crate) listener: TcpListener, pub(crate) inner_loop_delay: Duration, pub(crate) tm_source: TmSource, pub(crate) tm_buffer: Vec\u003cu8\u003e, pub(crate) tc_receiver: TcReceiver, pub(crate) tc_buffer: Vec\u003cu8\u003e, tc_handler: TcParser, tm_handler: TmSender, } This is the concrete strategy implementation for COBS TC parsing:\n/// Concrete [TcpTcParser] implementation for the [TcpTmtcInCobsServer]. #[derive(Default)] pub struct CobsTcParser {} impl\u003cTmError, TcError: 'static\u003e TcpTcParser\u003cTmError, TcError\u003e for CobsTcParser { fn handle_tc_parsing( \u0026mut self, tc_buffer: \u0026mut [u8], tc_receiver: \u0026mut (impl ReceivesTc\u003cError = TcError\u003e + ?Sized), conn_result: \u0026mut ConnectionResult, current_write_idx: usize, next_write_idx: \u0026mut usize, ) -\u003e Result\u003c(), TcpTmtcError\u003cTmError, TcError\u003e\u003e { conn_result.num_received_tcs += parse_buffer_for_cobs_encoded_packets( \u0026mut tc_buffer[..current_write_idx], tc_receiver.upcast_mut(), next_write_idx, ) .map_err(|e| TcpTmtcError::TcError(e))?; Ok(()) } } where the concrete parser implementation can be found here. This the the implementation for COBS TM sending:\n/// Concrete [TcpTmSender] implementation for the [TcpTmtcInCobsServer]. pub struct CobsTmSender { tm_encoding_buffer: Vec\u003cu8\u003e, } impl CobsTmSender { fn new(tm_buffer_size: usize) -\u003e Self { Self { // The buffer should be large enough to hold the maximum expected TM size encoded with // COBS. tm_encoding_buffer: vec![0; cobs::max_encoding_length(tm_buffer_size)], } } } impl\u003cTmError, TcError\u003e TcpTmSender\u003cTmError, TcError\u003e for CobsTmSender { fn handle_tm_sending( \u0026mut self, tm_buffer: \u0026mut [u8], tm_source: \u0026mut (impl TmPacketSource\u003cError = TmError\u003e + ?Sized), conn_result: \u0026mut ConnectionResult, stream: \u0026mut TcpStream, ) -\u003e Result\u003cbool, TcpTmtcError\u003cTmError, TcError\u003e\u003e { let mut tm_was_sent = false; loop { // Write TM until TM source is exhausted. For now, there is no limit for the amount // of TM written this way. let read_tm_len = tm_source .retrieve_packet(tm_buffer) .map_err(|e| TcpTmtcError::TmError(e))?; if read_tm_len == 0 { return Ok(tm_was_sent); } tm_was_sent = true; conn_result.num_sent_tms += 1; // Encode into COBS and sent to client. let mut current_idx = 0; self.tm_encoding_buffer[current_idx] = 0; current_idx += 1; current_idx += encode( \u0026tm_buffer[..read_tm_len], \u0026mut self.tm_encoding_buffer[current_idx..], ); self.tm_encoding_buffer[current_idx] = 0; current_idx += 1; stream.write_all(\u0026self.tm_encoding_buffer[..current_idx])?; } } } In addition to the encoding which removes 0 from the packet, we also wrap telemetry packets with the sentinel byte 0.\nFinally, we provide a concrete TcpTmtcInCobsServer class as a convenient object to instantiate a TCP server with the TC strategy set to the CobsTcParser and the TM strategy set to the CobsTmSender:\npub struct TcpTmtcInCobsServer\u003c TmError, TcError: 'static, TmSource: TmPacketSource\u003cError = TmError\u003e, TcReceiver: ReceivesTc\u003cError = TcError\u003e, \u003e { generic_server: TcpTmtcGenericServer\u003cTmError, TcError, TmSource, TcReceiver, CobsTmSender, CobsTcParser\u003e, } impl\u003c TmError: 'static, TcError: 'static, TmSource: TmPacketSource\u003cError = TmError\u003e, TcReceiver: ReceivesTc\u003cError = TcError\u003e, \u003e TcpTmtcInCobsServer\u003cTmError, TcError, TmSource, TcReceiver\u003e { /// Create a new TCP TMTC server which exchanges TMTC packets encoded with /// [COBS protocol](https://en.wikipedia.org/wiki/Consistent_Overhead_Byte_Stuffing). /// /// ## Parameter /// /// * `cfg` - Configuration of the server. /// * `tm_source` - Generic TM source used by the server to pull telemetry packets which are /// then sent back to the client. /// * `tc_receiver` - Any received telecommands which were decoded successfully will be /// forwarded to this TC receiver. pub fn new( cfg: ServerConfig, tm_source: TmSource, tc_receiver: TcReceiver, ) -\u003e Result\u003cSelf, TcpTmtcError\u003cTmError, TcError\u003e\u003e { Ok(Self { generic_server: TcpTmtcGenericServer::new( cfg, CobsTcParser::default(), CobsTmSender::new(cfg.tm_buffer_size), tm_source, tc_receiver, )?, }) } delegate! { to self.generic_server { pub fn listener(\u0026mut self) -\u003e \u0026mut TcpListener; /// Can be used to retrieve the local assigned address of the TCP server. This is especially /// useful if using the port number 0 for OS auto-assignment. pub fn local_addr(\u0026self) -\u003e std::io::Result\u003cSocketAddr\u003e; /// Delegation to the [TcpTmtcGenericServer::handle_next_connection] call. pub fn handle_next_connection( \u0026mut self, ) -\u003e Result\u003cConnectionResult, TcpTmtcError\u003cTmError, TcError\u003e\u003e; } } } I use the delegate crate to forwards all calls for the public API to the internal generic TCP server. You can find the source code for the implementation which can be used exchange CCSDS space packets here.\nConverting the code to use the strategy pattern definitely can be a challenge, but the good thing is that the core logic does not need to be changed or copy-and-pasted anymore when new encoding and decoding protocols for the data are required. The only thing that needs to be done is to create an own implementation of the strategy traits, and configure them via generics. In general, the strategy pattern is especially useful if you know that your class will have some common base logic with a few adaption point that should be user-configurable.\nConclusion I think transferring object oriented design patterns to Rust can be tricky when coming from object oriented languages like Java, C++ or Python, because Rust does has not classic inheritance. It is still possible to apply most design patterns in Rust as well, using composition, generics and trait, but I oftentimes have the issue that a lot of the examples and resources available are contrived or only applicable for very simple problems. This post showed how to apply the strategy pattern in Rust for a TCP server to reduce duplicate code and allow flexbily adding new ways to parse packets received for that server, and to send telemetry.\nhttps://refactoring.guru/images/patterns/diagrams/strategy/structure.png?id=c6aa910c94960f35d100bfca02810ea1 ↩︎\n","wordCount":"2189","inLanguage":"en","datePublished":"2023-09-29T15:17:13+02:00","dateModified":"2023-10-03T19:46:45+02:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://robamu.github.io/blog/rust-strategy-pattern/"},"publisher":{"@type":"Organization","name":"hi, I am robin","logo":{"@type":"ImageObject","url":"https://robamu.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://robamu.github.io/ accesskey=h title="hi, I am robin (Alt + H)">hi, I am robin</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://robamu.github.io/ title=Home><span>Home</span></a></li><li><a href=https://robamu.github.io/projects/ title=Projects><span>Projects</span></a></li><li><a href=https://robamu.github.io/blog/ title=Blog><span>Blog</span></a></li><li><a href=https://robamu.github.io/contact/ title=Contact><span>Contact</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Implementing a TCP server for Space Applications in Rust using the Strategy Pattern</h1><div class=post-meta><span title='2023-09-29 15:17:13 +0200 +0200'>September 29, 2023</span>&nbsp;·&nbsp;11 min&nbsp;·&nbsp;<span id=413adfe518230a0a5d5242edda76247f title=Views>? Views</span>
<script>var r=new XMLHttpRequest;r.addEventListener("load",function(){document.getElementById("413adfe518230a0a5d5242edda76247f").innerHTML=JSON.parse(this.responseText).count_unique+" Views"}),r.open("GET","https://robamu.goatcounter.com/counter/"+encodeURIComponent("/blog/rust-strategy-pattern/".replace(/(\/)?$/,""))+".json"),r.send()</script></div></header><div class=post-content><p>Even for space systems, TCP/IP is oftentimes an important component in some shape or form because
the majority of development might still occur on ground where an internet connection is still
available. The special thing about space is that instead of using newline and/or UTF-8 based
data, the data is generally in binary format and packet based. The most prevalent of the space
packet standards is probably the <a href=https://public.ccsds.org/Pubs/133x0b2e1.pdf>CCSDS Space Packet Protocol</a>.</p><p>TCP is always a tricky protocol when exchanging something like CCSDS space packets. UDP is
generally a better fit because a packet can simply be exchanged as a datagram. However, there
are special cases where TCP is simply more convenient, for example when using something like
SSH tunneling, which would require some <code>socat</code> trickery to use UDP. Sometimes, we would also like
to have the additional guarantees that TCP has in comparison to UDP.</p><h2 id=what-i-already-have>What I already have<a hidden class=anchor aria-hidden=true href=#what-i-already-have>#</a></h2><p>I already implemented a <a href=https://egit.irs.uni-stuttgart.de/fsfw/fsfw/src/branch/master/src/fsfw/osal/common/TcpTmTcServer.h>TCP server implementation for C++</a>
which is able to exchange tightly packed CCSDS space packets. The only thing all CCSDS space
packets have in common is a six byte header, shown in the following image:</p><center><figure><img loading=lazy src=/img/rust-strategy-pattern/ccsds-header.png alt="CCSDS space packet header"><figcaption><p>CCSDS space packet header</p></figcaption></figure></center><p>The Packet Identification field (Packet ID) can be used specifically as a start marker to
detect packets from a raw bytestream. After detecting the start of a packet, the fifth and sixth
byte can be used to know the size of the full packet. This still is not a perfect transport layer
in my opinion, because it is still missing proper framing. However, with the assumption that TCP
guarantees full data integrity and some robust CCSDS parsing, I am generally happy with this, as it
allows to simply send and read possibly multiple CCSDS space packets in one go without any
additional framing protocols on top.</p><h2 id=moving-to-rust>Moving to Rust<a hidden class=anchor aria-hidden=true href=#moving-to-rust>#</a></h2><p>I recently implemented a TCP server for the <a href=https://egit.irs.uni-stuttgart.de/rust/sat-rs><code>sat-rs</code></a>
Rust framework with the goal to have a similar behaviour as the C++ variant. Additionally, I also
had to goal to allow more than just CCSDS space packets by using the <a href=https://en.wikipedia.org/wiki/Consistent_Overhead_Byte_Stuffing>COBS</a>
protocol as a generic framing mechanism. This would in theory also allow to exchange something
like <a href=https://public.ccsds.org/Pubs/732x1b2.pdf>USLP frames</a>.</p><p>After implementing this second variant first, I quickly noticed that the first variant using
COBS encoded packets would share a lot of common code with the first variant exchanging CCSDS
space packets only. This is because the process of reading a bytestream and extracting frames from
that bytestream using a certain parsing protocol is common for both variants. The same is also
true for the telemetry sent back to a client: It might be necessary to apply some encoding logic
on the raw packets before sending them, but other than that, the logic is the same.</p><h2 id=the-strategy-pattern>The Strategy Pattern<a hidden class=anchor aria-hidden=true href=#the-strategy-pattern>#</a></h2><p>Coming from languages and projects which use object orientation heavily,
my first thought was to use the <a href=https://refactoring.guru/design-patterns/template-method>template method pattern</a> here. However, Rust does not allow
inheritance, so I quickly determined that the <a href=https://refactoring.guru/design-patterns/strategy>strategy pattern</a>
would be the best fit here.
If you do not know what the strategy pattern is, I recommend reading the <a href=https://refactoring.guru/design-patterns/strategy>article by Refactoring Guru</a>.
The following graph, which is taken from the article as well <sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>, shows the basic idea:</p><center><figure><img loading=lazy src=/img/rust-strategy-pattern/strategy-pattern.png alt="The Strategy Design Pattern"><figcaption><p>The Strategy Design Pattern</p></figcaption></figure></center><p>The strategy pattern allows to have a base algorithm with flexible adaption points which are called
strategies. This pattern can be mapped on our problem and to Rust: The context object will be our
generic TCP server which has some common logic to read TCs from a client and send back telemetry
to the client. The Strategy interface is some trait which supplies all information required to
parse telecommands from a raw bytestream or send telemetry back to the client. A concrete
implementation would then for example be a COBS decoder object.</p><h2 id=the-generic-tcp-server>The generic TCP server<a hidden class=anchor aria-hidden=true href=#the-generic-tcp-server>#</a></h2><p>The basic tasks of the generic TCP server object are the following:</p><ol><li>Listen for TCP connections.</li><li>If a client connects, accept the connection. Start reading the bytestream sent from the client
until it is exhausted, or the used TC buffer is full. Exhausted means that the client
stop sending telecommands (receiver timeout) or shuts down the writer side.</li><li>If something was read from the client, start parsing for frames. This is where the strategy
pattern comes in: I&rsquo;d like the parsing algorithm to be something which can be different
depending on which TC parsing strategy I am using, or more specifically, the strategy which
I configured for that class.</li><li>After a reader timeout or having read all packets, I also want to send back telemetry to the
client. Here, I might have to apply custom protocols to the packets I want to send as well,
so I want to apply an encoding algorithm depending on which TM strategy is used.</li></ol><p>After a bit of cleaning up, this is what the general structure of the primary connection handler
looked like, using some pseudo code as well:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>handle_next_connection</span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Result</span><span class=o>&lt;</span><span class=n>ConnectionResult</span><span class=p>,</span><span class=w> </span><span class=n>TcpTmtcError</span><span class=o>&lt;</span><span class=n>TmError</span><span class=p>,</span><span class=w> </span><span class=n>TcError</span><span class=o>&gt;&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// This contains some context data about the handled connection, e.g. amount of handled TC
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=c1>// and TM packets
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>connection_result</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>ConnectionResult</span>::<span class=n>default</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>current_write_idx</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>next_write_idx</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>0</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=k>mut</span><span class=w> </span><span class=n>stream</span><span class=p>,</span><span class=w> </span><span class=n>addr</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>tcp_listener</span><span class=p>.</span><span class=n>accept</span><span class=p>()</span><span class=o>?</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>stream</span><span class=p>.</span><span class=n>set_nonblocking</span><span class=p>(</span><span class=kc>true</span><span class=p>)</span><span class=o>?</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>connection_result</span><span class=p>.</span><span class=n>addr</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=n>addr</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>current_write_idx</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>next_write_idx</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>loop</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>read_result</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>stream</span><span class=p>.</span><span class=n>read</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>tc_buffer</span><span class=p>[</span><span class=n>current_write_idx</span><span class=o>..</span><span class=p>]);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>match</span><span class=w> </span><span class=n>read_result</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nb>Ok</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=c1>// Connection closed by client. If any TC was read, parse for complete packets.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>                </span><span class=c1>// After that, break the outer loop.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>                </span><span class=k>if</span><span class=w> </span><span class=n>current_write_idx</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=bp>self</span><span class=p>.</span><span class=n>tc_handler</span><span class=p>.</span><span class=n>handle_tc_parsing</span><span class=p>(</span><span class=o>..</span><span class=p>.)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>break</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nb>Ok</span><span class=p>(</span><span class=n>read_len</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>current_write_idx</span><span class=w> </span><span class=o>+=</span><span class=w> </span><span class=n>read_len</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=c1>// TC buffer is full, we must parse for complete packets now.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>                </span><span class=k>if</span><span class=w> </span><span class=n>current_write_idx</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>tc_buffer</span><span class=p>.</span><span class=n>capacity</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=bp>self</span><span class=p>.</span><span class=n>tc_handler</span><span class=p>.</span><span class=n>handle_tc_parsing</span><span class=p>(</span><span class=o>..</span><span class=p>.)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=n>current_write_idx</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>next_write_idx</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nb>Err</span><span class=p>(</span><span class=n>e</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=k>match</span><span class=w> </span><span class=n>e</span><span class=p>.</span><span class=n>kind</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=c1>// As per [TcpStream::set_read_timeout] documentation, this should work for
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>                </span><span class=c1>// both UNIX and Windows.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>                </span><span class=n>std</span>::<span class=n>io</span>::<span class=n>ErrorKind</span>::<span class=n>WouldBlock</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=n>std</span>::<span class=n>io</span>::<span class=n>ErrorKind</span>::<span class=n>TimedOut</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=bp>self</span><span class=p>.</span><span class=n>tc_handler</span><span class=p>.</span><span class=n>handle_tc_parsing</span><span class=p>(</span><span class=o>..</span><span class=p>.)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=n>current_write_idx</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>next_write_idx</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=k>if</span><span class=w> </span><span class=o>!</span><span class=bp>self</span><span class=p>.</span><span class=n>tm_handler</span><span class=p>.</span><span class=n>handle_tm_sending</span><span class=p>(</span><span class=o>..</span><span class=p>.)</span><span class=o>?</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=c1>// No TC read, no TM was sent, but the client has not disconnected.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>                        </span><span class=c1>// Perform an inner delay to avoid burning CPU time.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>                        </span><span class=n>thread</span>::<span class=n>sleep</span><span class=p>(</span><span class=bp>self</span><span class=p>.</span><span class=n>base</span><span class=p>.</span><span class=n>inner_loop_delay</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>_</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=k>return</span><span class=w> </span><span class=nb>Err</span><span class=p>(</span><span class=n>TcpTmtcError</span>::<span class=n>Io</span><span class=p>(</span><span class=n>e</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>},</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=bp>self</span><span class=p>.</span><span class=n>tm_handler</span><span class=p>.</span><span class=n>handle_tm_sending</span><span class=p>(</span><span class=o>..</span><span class=p>.)</span><span class=o>?</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nb>Ok</span><span class=p>(</span><span class=n>connection_result</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h2 id=the-strategy-interface-and-implementation>The Strategy Interface and Implementation<a hidden class=anchor aria-hidden=true href=#the-strategy-interface-and-implementation>#</a></h2><p>In languages like C++ or Java, the strategy is generally an abstract interface specification
which is then implemented in form of concrete strategy objects. These concrete objects are then
passed to the context object which expects a concrete strategy as the adaption point for users.
In Rust, we can do these in a similar way: We specify an interface as a trait which provides
all information necessary to perform the parsing of telecommands or the encoding of telemetry.
In the example above, the <code>tc_parser</code> and <code>tm_handler</code> objects are either trait objects member or
generic members of the generic TCP server which implement the corresponding strategy traits.</p><p>After determining the necessary information for implementing the strategy, I have the
following traits:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=sd>/// Generic parser abstraction for an object which can parse for telecommands given a raw
</span></span></span><span class=line><span class=cl><span class=sd>/// bytestream received from a TCP socket and send them to a generic [ReceivesTc] telecommand
</span></span></span><span class=line><span class=cl><span class=sd>/// receiver. This allows different encoding schemes for telecommands.
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=k>pub</span><span class=w> </span><span class=k>trait</span><span class=w> </span><span class=n>TcpTcParser</span><span class=o>&lt;</span><span class=n>TmError</span><span class=p>,</span><span class=w> </span><span class=n>TcError</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>handle_tc_parsing</span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>tc_buffer</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=p>[</span><span class=kt>u8</span><span class=p>],</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>tc_receiver</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=p>(</span><span class=k>impl</span><span class=w> </span><span class=n>ReceivesTc</span><span class=o>&lt;</span><span class=n>Error</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>TcError</span><span class=o>&gt;</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=o>?</span><span class=nb>Sized</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>conn_result</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=n>ConnectionResult</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>current_write_idx</span>: <span class=kt>usize</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>next_write_idx</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=kt>usize</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Result</span><span class=o>&lt;</span><span class=p>(),</span><span class=w> </span><span class=n>TcpTmtcError</span><span class=o>&lt;</span><span class=n>TmError</span><span class=p>,</span><span class=w> </span><span class=n>TcError</span><span class=o>&gt;&gt;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=sd>/// Generic sender abstraction for an object which can pull telemetry from a given TM source
</span></span></span><span class=line><span class=cl><span class=sd>/// using a [TmPacketSource] and then send them back to a client using a given [TcpStream].
</span></span></span><span class=line><span class=cl><span class=sd>/// The concrete implementation can also perform any encoding steps which are necessary before
</span></span></span><span class=line><span class=cl><span class=sd>/// sending back the data to a client.
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=k>pub</span><span class=w> </span><span class=k>trait</span><span class=w> </span><span class=n>TcpTmSender</span><span class=o>&lt;</span><span class=n>TmError</span><span class=p>,</span><span class=w> </span><span class=n>TcError</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>handle_tm_sending</span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>tm_buffer</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=p>[</span><span class=kt>u8</span><span class=p>],</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>tm_source</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=p>(</span><span class=k>impl</span><span class=w> </span><span class=n>TmPacketSource</span><span class=o>&lt;</span><span class=n>Error</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>TmError</span><span class=o>&gt;</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=o>?</span><span class=nb>Sized</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>conn_result</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=n>ConnectionResult</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>stream</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=n>TcpStream</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Result</span><span class=o>&lt;</span><span class=kt>bool</span><span class=p>,</span><span class=w> </span><span class=n>TcpTmtcError</span><span class=o>&lt;</span><span class=n>TmError</span><span class=p>,</span><span class=w> </span><span class=n>TcError</span><span class=o>&gt;&gt;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>Also note that we use another set of traits to allow passing found TC packets to a user using
a generic <a href=https://docs.rs/satrs-core/0.1.0-alpha.1/satrs_core/tmtc/trait.ReceivesTcCore.html><code>ReceivesTcCore</code> base</a>
trait. We also use a <a href=https://docs.rs/satrs-core/0.1.0-alpha.1/satrs_core/tmtc/trait.TmPacketSourceCore.html><code>TmPacketSourceCore</code> base</a> trait as the generic trait for
user supplied telemetry packets. These also fit into the strategy pattern by allowing the user
to modify TC forwarding and TM specification through a generic contract.</p><p>We can now use generics to specify the strategy for the generic object.
The generic TCP server class then looks like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>pub</span><span class=w> </span><span class=k>struct</span> <span class=nc>TcpTmtcGenericServer</span><span class=o>&lt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>TmError</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>TcError</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>TmSource</span>: <span class=nc>TmPacketSource</span><span class=o>&lt;</span><span class=n>Error</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>TmError</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>TcReceiver</span>: <span class=nc>ReceivesTc</span><span class=o>&lt;</span><span class=n>Error</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>TcError</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>TmSender</span>: <span class=nc>TcpTmSender</span><span class=o>&lt;</span><span class=n>TmError</span><span class=p>,</span><span class=w> </span><span class=n>TcError</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>TcParser</span>: <span class=nc>TcpTcParser</span><span class=o>&lt;</span><span class=n>TmError</span><span class=p>,</span><span class=w> </span><span class=n>TcError</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>pub</span><span class=p>(</span><span class=k>crate</span><span class=p>)</span><span class=w> </span><span class=n>listener</span>: <span class=nc>TcpListener</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>pub</span><span class=p>(</span><span class=k>crate</span><span class=p>)</span><span class=w> </span><span class=n>inner_loop_delay</span>: <span class=nc>Duration</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>pub</span><span class=p>(</span><span class=k>crate</span><span class=p>)</span><span class=w> </span><span class=n>tm_source</span>: <span class=nc>TmSource</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>pub</span><span class=p>(</span><span class=k>crate</span><span class=p>)</span><span class=w> </span><span class=n>tm_buffer</span>: <span class=nb>Vec</span><span class=o>&lt;</span><span class=kt>u8</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>pub</span><span class=p>(</span><span class=k>crate</span><span class=p>)</span><span class=w> </span><span class=n>tc_receiver</span>: <span class=nc>TcReceiver</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>pub</span><span class=p>(</span><span class=k>crate</span><span class=p>)</span><span class=w> </span><span class=n>tc_buffer</span>: <span class=nb>Vec</span><span class=o>&lt;</span><span class=kt>u8</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>tc_handler</span>: <span class=nc>TcParser</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>tm_handler</span>: <span class=nc>TmSender</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>This is the concrete strategy <a href=https://egit.irs.uni-stuttgart.de/rust/sat-rs/src/commit/8cab8ab011190ca29f750637e01cb208d7525046/satrs-core/src/hal/std/tcp_cobs_server.rs#L20>implementation</a>
for COBS TC parsing:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=sd>/// Concrete [TcpTcParser] implementation for the [TcpTmtcInCobsServer].
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=cp>#[derive(Default)]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>pub</span><span class=w> </span><span class=k>struct</span> <span class=nc>CobsTcParser</span><span class=w> </span><span class=p>{}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>impl</span><span class=o>&lt;</span><span class=n>TmError</span><span class=p>,</span><span class=w> </span><span class=n>TcError</span>: <span class=nb>&#39;static</span><span class=o>&gt;</span><span class=w> </span><span class=n>TcpTcParser</span><span class=o>&lt;</span><span class=n>TmError</span><span class=p>,</span><span class=w> </span><span class=n>TcError</span><span class=o>&gt;</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>CobsTcParser</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>handle_tc_parsing</span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>tc_buffer</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=p>[</span><span class=kt>u8</span><span class=p>],</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>tc_receiver</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=p>(</span><span class=k>impl</span><span class=w> </span><span class=n>ReceivesTc</span><span class=o>&lt;</span><span class=n>Error</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>TcError</span><span class=o>&gt;</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=o>?</span><span class=nb>Sized</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>conn_result</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=n>ConnectionResult</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>current_write_idx</span>: <span class=kt>usize</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>next_write_idx</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=kt>usize</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Result</span><span class=o>&lt;</span><span class=p>(),</span><span class=w> </span><span class=n>TcpTmtcError</span><span class=o>&lt;</span><span class=n>TmError</span><span class=p>,</span><span class=w> </span><span class=n>TcError</span><span class=o>&gt;&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>conn_result</span><span class=p>.</span><span class=n>num_received_tcs</span><span class=w> </span><span class=o>+=</span><span class=w> </span><span class=n>parse_buffer_for_cobs_encoded_packets</span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>tc_buffer</span><span class=p>[</span><span class=o>..</span><span class=n>current_write_idx</span><span class=p>],</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>tc_receiver</span><span class=p>.</span><span class=n>upcast_mut</span><span class=p>(),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>next_write_idx</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>.</span><span class=n>map_err</span><span class=p>(</span><span class=o>|</span><span class=n>e</span><span class=o>|</span><span class=w> </span><span class=n>TcpTmtcError</span>::<span class=n>TcError</span><span class=p>(</span><span class=n>e</span><span class=p>))</span><span class=o>?</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nb>Ok</span><span class=p>(())</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>where the concrete parser implementation can be found
<a href=https://egit.irs.uni-stuttgart.de/rust/sat-rs/src/commit/ef8417d9dbb73cf170e602a2759f270c98a1ba0b/satrs-core/src/encoding/cobs.rs#L58>here</a>.
This the the <a href=https://egit.irs.uni-stuttgart.de/rust/sat-rs/src/commit/8cab8ab011190ca29f750637e01cb208d7525046/satrs-core/src/hal/std/tcp_cobs_server.rs#L42>implementation</a> for COBS TM sending:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=sd>/// Concrete [TcpTmSender] implementation for the [TcpTmtcInCobsServer].
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=k>pub</span><span class=w> </span><span class=k>struct</span> <span class=nc>CobsTmSender</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>tm_encoding_buffer</span>: <span class=nb>Vec</span><span class=o>&lt;</span><span class=kt>u8</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>impl</span><span class=w> </span><span class=n>CobsTmSender</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>new</span><span class=p>(</span><span class=n>tm_buffer_size</span>: <span class=kt>usize</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Self</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=bp>Self</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// The buffer should be large enough to hold the maximum expected TM size encoded with
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>            </span><span class=c1>// COBS.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>            </span><span class=n>tm_encoding_buffer</span>: <span class=nc>vec</span><span class=o>!</span><span class=p>[</span><span class=mi>0</span><span class=p>;</span><span class=w> </span><span class=n>cobs</span>::<span class=n>max_encoding_length</span><span class=p>(</span><span class=n>tm_buffer_size</span><span class=p>)],</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>impl</span><span class=o>&lt;</span><span class=n>TmError</span><span class=p>,</span><span class=w> </span><span class=n>TcError</span><span class=o>&gt;</span><span class=w> </span><span class=n>TcpTmSender</span><span class=o>&lt;</span><span class=n>TmError</span><span class=p>,</span><span class=w> </span><span class=n>TcError</span><span class=o>&gt;</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>CobsTmSender</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>handle_tm_sending</span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>tm_buffer</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=p>[</span><span class=kt>u8</span><span class=p>],</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>tm_source</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=p>(</span><span class=k>impl</span><span class=w> </span><span class=n>TmPacketSource</span><span class=o>&lt;</span><span class=n>Error</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>TmError</span><span class=o>&gt;</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=o>?</span><span class=nb>Sized</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>conn_result</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=n>ConnectionResult</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>stream</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=n>TcpStream</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Result</span><span class=o>&lt;</span><span class=kt>bool</span><span class=p>,</span><span class=w> </span><span class=n>TcpTmtcError</span><span class=o>&lt;</span><span class=n>TmError</span><span class=p>,</span><span class=w> </span><span class=n>TcError</span><span class=o>&gt;&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>tm_was_sent</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>false</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>loop</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// Write TM until TM source is exhausted. For now, there is no limit for the amount
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>            </span><span class=c1>// of TM written this way.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>            </span><span class=kd>let</span><span class=w> </span><span class=n>read_tm_len</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>tm_source</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>.</span><span class=n>retrieve_packet</span><span class=p>(</span><span class=n>tm_buffer</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>.</span><span class=n>map_err</span><span class=p>(</span><span class=o>|</span><span class=n>e</span><span class=o>|</span><span class=w> </span><span class=n>TcpTmtcError</span>::<span class=n>TmError</span><span class=p>(</span><span class=n>e</span><span class=p>))</span><span class=o>?</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=n>read_tm_len</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>return</span><span class=w> </span><span class=nb>Ok</span><span class=p>(</span><span class=n>tm_was_sent</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>tm_was_sent</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>true</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>conn_result</span><span class=p>.</span><span class=n>num_sent_tms</span><span class=w> </span><span class=o>+=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// Encode into COBS and sent to client.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>            </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>current_idx</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>0</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=bp>self</span><span class=p>.</span><span class=n>tm_encoding_buffer</span><span class=p>[</span><span class=n>current_idx</span><span class=p>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>0</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>current_idx</span><span class=w> </span><span class=o>+=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>current_idx</span><span class=w> </span><span class=o>+=</span><span class=w> </span><span class=n>encode</span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=o>&amp;</span><span class=n>tm_buffer</span><span class=p>[</span><span class=o>..</span><span class=n>read_tm_len</span><span class=p>],</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>tm_encoding_buffer</span><span class=p>[</span><span class=n>current_idx</span><span class=o>..</span><span class=p>],</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=bp>self</span><span class=p>.</span><span class=n>tm_encoding_buffer</span><span class=p>[</span><span class=n>current_idx</span><span class=p>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>0</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>current_idx</span><span class=w> </span><span class=o>+=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>stream</span><span class=p>.</span><span class=n>write_all</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>.</span><span class=n>tm_encoding_buffer</span><span class=p>[</span><span class=o>..</span><span class=n>current_idx</span><span class=p>])</span><span class=o>?</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>In addition to the encoding which removes 0 from the packet, we also wrap telemetry packets with
the sentinel byte 0.</p><p>Finally, we provide a concrete <code>TcpTmtcInCobsServer</code> class as a convenient object to instantiate
a TCP server with the TC strategy set to the <code>CobsTcParser</code> and the TM strategy set to the
<code>CobsTmSender</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>pub</span><span class=w> </span><span class=k>struct</span> <span class=nc>TcpTmtcInCobsServer</span><span class=o>&lt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>TmError</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>TcError</span>: <span class=nb>&#39;static</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>TmSource</span>: <span class=nc>TmPacketSource</span><span class=o>&lt;</span><span class=n>Error</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>TmError</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>TcReceiver</span>: <span class=nc>ReceivesTc</span><span class=o>&lt;</span><span class=n>Error</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>TcError</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>generic_server</span>:
</span></span><span class=line><span class=cl>        <span class=nc>TcpTmtcGenericServer</span><span class=o>&lt;</span><span class=n>TmError</span><span class=p>,</span><span class=w> </span><span class=n>TcError</span><span class=p>,</span><span class=w> </span><span class=n>TmSource</span><span class=p>,</span><span class=w> </span><span class=n>TcReceiver</span><span class=p>,</span><span class=w> </span><span class=n>CobsTmSender</span><span class=p>,</span><span class=w> </span><span class=n>CobsTcParser</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>impl</span><span class=o>&lt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>TmError</span>: <span class=nb>&#39;static</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>TcError</span>: <span class=nb>&#39;static</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>TmSource</span>: <span class=nc>TmPacketSource</span><span class=o>&lt;</span><span class=n>Error</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>TmError</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>TcReceiver</span>: <span class=nc>ReceivesTc</span><span class=o>&lt;</span><span class=n>Error</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>TcError</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=o>&gt;</span><span class=w> </span><span class=n>TcpTmtcInCobsServer</span><span class=o>&lt;</span><span class=n>TmError</span><span class=p>,</span><span class=w> </span><span class=n>TcError</span><span class=p>,</span><span class=w> </span><span class=n>TmSource</span><span class=p>,</span><span class=w> </span><span class=n>TcReceiver</span><span class=o>&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=sd>/// Create a new TCP TMTC server which exchanges TMTC packets encoded with
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>    </span><span class=sd>/// [COBS protocol](https://en.wikipedia.org/wiki/Consistent_Overhead_Byte_Stuffing).
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>    </span><span class=sd>///
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>    </span><span class=sd>/// ## Parameter
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>    </span><span class=sd>///
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>    </span><span class=sd>/// * `cfg` - Configuration of the server.
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>    </span><span class=sd>/// * `tm_source` - Generic TM source used by the server to pull telemetry packets which are
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>    </span><span class=sd>///     then sent back to the client.
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>    </span><span class=sd>/// * `tc_receiver` - Any received telecommands which were decoded successfully will be
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>    </span><span class=sd>///     forwarded to this TC receiver.
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>new</span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>cfg</span>: <span class=nc>ServerConfig</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>tm_source</span>: <span class=nc>TmSource</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>tc_receiver</span>: <span class=nc>TcReceiver</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Result</span><span class=o>&lt;</span><span class=bp>Self</span><span class=p>,</span><span class=w> </span><span class=n>TcpTmtcError</span><span class=o>&lt;</span><span class=n>TmError</span><span class=p>,</span><span class=w> </span><span class=n>TcError</span><span class=o>&gt;&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nb>Ok</span><span class=p>(</span><span class=bp>Self</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>generic_server</span>: <span class=nc>TcpTmtcGenericServer</span>::<span class=n>new</span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>cfg</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>CobsTcParser</span>::<span class=n>default</span><span class=p>(),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>CobsTmSender</span>::<span class=n>new</span><span class=p>(</span><span class=n>cfg</span><span class=p>.</span><span class=n>tm_buffer_size</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>tm_source</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>tc_receiver</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>)</span><span class=o>?</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>})</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=fm>delegate!</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>to</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>generic_server</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>listener</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=n>TcpListener</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=sd>/// Can be used to retrieve the local assigned address of the TCP server. This is especially
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>            </span><span class=sd>/// useful if using the port number 0 for OS auto-assignment.
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>            </span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>local_addr</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>std</span>::<span class=n>io</span>::<span class=nb>Result</span><span class=o>&lt;</span><span class=n>SocketAddr</span><span class=o>&gt;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=sd>/// Delegation to the [TcpTmtcGenericServer::handle_next_connection] call.
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>            </span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>handle_next_connection</span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Result</span><span class=o>&lt;</span><span class=n>ConnectionResult</span><span class=p>,</span><span class=w> </span><span class=n>TcpTmtcError</span><span class=o>&lt;</span><span class=n>TmError</span><span class=p>,</span><span class=w> </span><span class=n>TcError</span><span class=o>&gt;&gt;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>I use the <a href=https://crates.io/crates/delegate><code>delegate</code></a> crate to forwards all calls for the
public API to the internal generic TCP server. You can find the source code for the implementation
which can be used exchange CCSDS space packets
<a href=https://docs.rs/satrs-core/0.1.0-alpha.1/src/satrs_core/hal/std/tcp_spacepackets_server.rs.html>here</a>.</p><p>Converting the code to use the strategy pattern definitely can be a challenge, but the good thing
is that the core logic does not need to be changed or copy-and-pasted anymore when new encoding
and decoding protocols for the data are required. The only thing that needs to be done is to
create an own implementation of the strategy traits, and configure them via generics. In general,
the strategy pattern is especially useful if you know that your class will have some common base
logic with a few adaption point that should be user-configurable.</p><h1 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h1><p>I think transferring object oriented design patterns to Rust can be tricky when coming
from object oriented languages like Java, C++ or Python, because Rust does has not classic
inheritance. It is still possible to apply most design patterns in Rust as well, using composition,
generics and trait, but I oftentimes have the issue that a lot of the examples and resources
available are contrived or only applicable for very simple problems.
This post showed how to apply the strategy pattern in Rust for a TCP server to reduce duplicate
code and allow flexbily adding new ways to parse packets received for that server, and to send
telemetry.</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p><a href="https://refactoring.guru/images/patterns/diagrams/strategy/structure.png?id=c6aa910c94960f35d100bfca02810ea1">https://refactoring.guru/images/patterns/diagrams/strategy/structure.png?id=c6aa910c94960f35d100bfca02810ea1</a>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://robamu.github.io/tags/rust/>Rust</a></li><li><a href=https://robamu.github.io/tags/design-pattern/>Design-Pattern</a></li><li><a href=https://robamu.github.io/tags/tcp/>Tcp</a></li><li><a href=https://robamu.github.io/tags/space/>Space</a></li></ul><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Implementing a TCP server for Space Applications in Rust using the Strategy Pattern on x" href="https://x.com/intent/tweet/?text=Implementing%20a%20TCP%20server%20for%20Space%20Applications%20in%20Rust%20using%20the%20Strategy%20Pattern&amp;url=https%3a%2f%2frobamu.github.io%2fblog%2frust-strategy-pattern%2f&amp;hashtags=rust%2cdesign-pattern%2ctcp%2cspace"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Implementing a TCP server for Space Applications in Rust using the Strategy Pattern on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2frobamu.github.io%2fblog%2frust-strategy-pattern%2f&amp;title=Implementing%20a%20TCP%20server%20for%20Space%20Applications%20in%20Rust%20using%20the%20Strategy%20Pattern&amp;summary=Implementing%20a%20TCP%20server%20for%20Space%20Applications%20in%20Rust%20using%20the%20Strategy%20Pattern&amp;source=https%3a%2f%2frobamu.github.io%2fblog%2frust-strategy-pattern%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Implementing a TCP server for Space Applications in Rust using the Strategy Pattern on reddit" href="https://reddit.com/submit?url=https%3a%2f%2frobamu.github.io%2fblog%2frust-strategy-pattern%2f&title=Implementing%20a%20TCP%20server%20for%20Space%20Applications%20in%20Rust%20using%20the%20Strategy%20Pattern"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Implementing a TCP server for Space Applications in Rust using the Strategy Pattern on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2frobamu.github.io%2fblog%2frust-strategy-pattern%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Implementing a TCP server for Space Applications in Rust using the Strategy Pattern on whatsapp" href="https://api.whatsapp.com/send?text=Implementing%20a%20TCP%20server%20for%20Space%20Applications%20in%20Rust%20using%20the%20Strategy%20Pattern%20-%20https%3a%2f%2frobamu.github.io%2fblog%2frust-strategy-pattern%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Implementing a TCP server for Space Applications in Rust using the Strategy Pattern on telegram" href="https://telegram.me/share/url?text=Implementing%20a%20TCP%20server%20for%20Space%20Applications%20in%20Rust%20using%20the%20Strategy%20Pattern&amp;url=https%3a%2f%2frobamu.github.io%2fblog%2frust-strategy-pattern%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Implementing a TCP server for Space Applications in Rust using the Strategy Pattern on ycombinator" href="https://news.ycombinator.com/submitlink?t=Implementing%20a%20TCP%20server%20for%20Space%20Applications%20in%20Rust%20using%20the%20Strategy%20Pattern&u=https%3a%2f%2frobamu.github.io%2fblog%2frust-strategy-pattern%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//https-robamu-github-io.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></article></main><script data-goatcounter=https://robamu.goatcounter.com/count async src=//gc.zgo.at/count.js></script><footer class=footer><span>&copy; 2025 <a href=https://robamu.github.io/>hi, I am robin</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>